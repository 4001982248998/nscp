import feature : feature ;
import project ;
import "class" : new ;
import targets ;
import property-set ;
import common ;
import type ;
import toolset : flags ;

# Make this module into a project.
project.initialize $(__name__) ;
project lua ;

#feature lua : on off : composite propagated link-incompatible ;

if [ MATCH (--debug-configuration) : [ modules.peek : ARGV ] ]
{
   .debug-configuration = true ;
}

rule initialized ( )
{
    return $(.initialized) ;
}

rule isEnabled ( )
{
    return $(.enabled) ;
}

rule isDebug ( )
{
    return $(.debug-configuration) ;
}

rule printEnv ( ) 
{
	echo "LUA SOURCE : change with --with-lua=<source>" ;
	echo "LUA SOURCE : $(.source) (change with --with-lua=<source>" ;
}

# Initialize Lua support.
rule init (
    version ? :
    source         # Location of source files
    )
{

	if $(.initialized)
	{
		errors.error "Attempt the reinitialize Lua!" ;
	}
	else
	{
		.initialized = true ;
		.source = $(source) ;

		local has-lua = [ MATCH "^--with-lua=(.*)" : [ modules.peek : ARGV ] ] ;
		if $(has-lua) {
			.source = $(has-lua) ;
		}
		
		if ( ( --with-lua in  [ modules.peek : ARGV ] ) || $(has-lua) )  
			&& ! ( --without-lua in  [ modules.peek : ARGV ] ) {
			.enabled = true ;
			} else {
			.enabled = false ;
		}
		
	    local project = [ project.current ] ;
		project.pop-current ;
	}
}
rule generate-source ( properties * )
{
	local path = $(.source)/src ;
	local result ;
	result += <source>$(path)/lapi.c ;
	result += <source>$(path)/lauxlib.c ;
	result += <source>$(path)/lbaselib.c ;
	result += <source>$(path)/lcode.c ;
	result += <source>$(path)/ldblib.c ;
	result += <source>$(path)/ldebug.c ;
	result += <source>$(path)/ldo.c ;
	result += <source>$(path)/ldump.c ;
	result += <source>$(path)/lfunc.c ;
	result += <source>$(path)/lgc.c ;
	result += <source>$(path)/linit.c ;
	result += <source>$(path)/liolib.c ;
	result += <source>$(path)/llex.c ;
	result += <source>$(path)/lmathlib.c ;
	result += <source>$(path)/lmem.c ;
	result += <source>$(path)/loadlib.c ;
	result += <source>$(path)/lobject.c ;
	result += <source>$(path)/lopcodes.c ;
	result += <source>$(path)/loslib.c ;
	result += <source>$(path)/lparser.c ;
	result += <source>$(path)/lstate.c ;
	result += <source>$(path)/lstring.c ;
	result += <source>$(path)/lstrlib.c ;
	result += <source>$(path)/ltable.c ;
	result += <source>$(path)/ltablib.c ;
	result += <source>$(path)/ltm.c ;
	result += <source>$(path)/lundump.c ;
	result += <source>$(path)/lvm.c ;
	result += <source>$(path)/lzio.c ;
	return $(result) ;
}

lib liblua
	: # sources
	: # requirements
		<conditional>@generate-source
		#<runtime-link>static
		<link>static
		#<name>liblua
	: # default-build
	: # usage-requirements
		$(usage-requirements) 
	;

alias embedded : liblua 

	: # requirements
	  #<name>lua
	: # default-build
	: # usage-requirements
	  <define>USE_LUA
	  <include>$(self.source)
	  $(usage-requirements) 
	;
